<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TfL Panel</title>

<style>
body{
  margin:0; background:#000; color:#fff; font-family:sans-serif;
  min-height:100vh; overflow-y:auto; -webkit-overflow-scrolling:touch;
}

.header{
  position:sticky; top:0; z-index:10;
  padding:18px 60px; background:#000;
  border-bottom:2px solid #111;
  display:flex; justify-content:space-between; align-items:center;
}
#topDay{ font-size:52px; font-weight:600; letter-spacing:.5px; }
#topDate,#lastUpdate{ font-size:22px; color:#9a9a9a; }
#topTime{ font-size:72px; font-weight:600; letter-spacing:1px; line-height:1; text-align:right; }

.wrap{ padding:26px 60px 90px; display:grid; gap:24px; }
.card{ border:2px solid #222; border-radius:18px; padding:22px 26px; background:#050505; }
.title{ font-size:58px; font-weight:600; display:flex; justify-content:space-between; align-items:center; }
.subtitle{ font-size:26px; opacity:.7; margin:0 0 18px 0; }

.list{ display:flex; flex-direction:column; gap:10px; }
.row{ padding:8px 0; border-bottom:1px solid #111; }
.row:last-child{ border-bottom:none; }

.topline{ display:flex; justify-content:space-between; align-items:baseline; font-size:44px; line-height:1.25; }
.left{ display:flex; gap:14px; min-width:0; }
.line{ white-space:nowrap; font-weight:600; }
.pipe{ opacity:.6; }
.dest{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; font-weight:400; }

.eta{ font-weight:700; white-space:nowrap; }

.eta.soon15{ color:#45a9ff; }

.eta.busgreen{ color:#4cff4c; }

.eta.bussoon{ color:#ffd54d; }

.eta.depart{ color:#ff4b4b; }

.subline{ font-size:26px; color:#9a9a9a; line-height:1.25; padding-bottom:4px; }

.pill{
  font-size:26px; padding:3px 14px;
  border:1px solid #333; border-radius:999px;
  display:inline-block;
}
.pill.live{ animation:livePulse 3.8s ease-in-out infinite; }
@keyframes livePulse{
  0%,100%{ opacity:.75; transform:scale(1); }
  50%{ opacity:1; transform:scale(1.04); }
}

.muted{ opacity:.65; }
.bigmsg{ font-size:34px; opacity:.8; padding:8px 0; }
</style>
</head>

<body>
<div class="header">
  <div class="h-left">
    <div id="topDay">--</div>
    <div id="topDate">--</div>
  </div>
  <div class="h-right">
    <div id="topTime">--:--:--</div>
    <div id="lastUpdate">Ostatnia aktualizacja: --:--:--</div>
  </div>
</div>

<div class="wrap">

  <section class="card">
    <div class="title">
      <span>Alexandra Palace</span>
      <span id="railStatus" class="pill muted">odświeżanie...</span>
    </div>
    <div class="subtitle">Najbliższe pociągi przez Highbury &amp; Islington lub Finsbury Park</div>
    <div id="railList" class="list muted">Ładowanie danych...</div>
    <div id="railFallback" class="bigmsg muted" style="display:none;">
      Brak danych RTT (sprawdź proxy).
    </div>
  </section>

  <section class="card">
    <div class="title">
      <span>Nightingale Road</span>
      <span id="busStatus" class="pill muted">odświeżanie...</span>
    </div>
    <div class="subtitle">Najbliższe autobusy (221 + N91) przez Bounds Green</div>
    <div id="busList" class="list muted">Ładowanie danych...</div>
  </section>

  <section class="card">
    <div class="title">
      <span>Bounds Green</span>
      <span id="tubeStatus" class="pill muted">odświeżanie...</span>
    </div>
    <div class="subtitle">Najbliższe metro przez Finsbury Park (kierunek centrum)</div>
    <div id="tubeList" class="list muted">Ładowanie danych...</div>
  </section>

</div>

<script>
const API_BASE = "http://127.0.0.1:5010";
const REFRESH_FALLBACK_MS = 60_000;
const FETCH_TIMEOUT_MS = 8000;
const MAX_ITEMS = 5;

const BUS_STOP_ID  = "490010277W";
const BUS_PRIMARY  = "221";
const BUS_FALLBACK = "N91";

const TUBE_LINE_ID = "piccadilly";
const TUBE_STOP_ID = "940GZZLUBDS";

const RTT_URL = `${API_BASE}/api/trains`;
const BUS_URL = `${API_BASE}/api/tfl/stop/${BUS_STOP_ID}/arrivals`;
const TUBE_URL = `${API_BASE}/api/tfl/line/${TUBE_LINE_ID}/arrivals/${TUBE_STOP_ID}`;

const BACKOFF_BASE_MS = 2000;
const BACKOFF_MAX_MS = 120_000;

const topDay = document.getElementById("topDay");
const topDate = document.getElementById("topDate");
const topTime = document.getElementById("topTime");
const lastUpdate = document.getElementById("lastUpdate");

const railList = document.getElementById("railList");
const railFallback = document.getElementById("railFallback");
const busList = document.getElementById("busList");
const tubeList = document.getElementById("tubeList");

const timers = { rail: null, bus: null, tube: null };
const backoff = { rail: 0, bus: 0, tube: 0 };

const esc = v => String(v ?? "").replace(/[&<>"']/g, m => ({
  "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
}[m]));

const mins = s => Math.max(0, Math.floor((s || 0) / 60));
const byTime = (a,b) => (a.timeToStation ?? 1e12) - (b.timeToStation ?? 1e12);

const toSecs = x => {
  const n = Number(x);
  return Number.isFinite(n) ? n : 0;
};

const jitter = ms => Math.round(ms * (0.7 + Math.random() * 0.6));

function setStatus(id, ok){
  const el = document.getElementById(id);
  el.textContent = ok ? "na żywo" : "brak danych";
  el.classList.toggle("muted", !ok);
  el.classList.toggle("live", ok);
}

function renderRows(id, rows){
  const el = document.getElementById(id);
  el.classList.remove("muted");
  el.innerHTML = rows.join("");
}

function renderMessage(id, msg){
  const el = document.getElementById(id);
  el.classList.add("muted");
  el.textContent = msg;
}

function schedule(name, fn, delayMs){
  clearTimeout(timers[name]);
  timers[name] = setTimeout(fn, delayMs);
}

function nextDelayFromTtl(ttlSec){
  // Respect upstream TTLs to avoid over-polling.
  const ttlMs = Math.max(0, toSecs(ttlSec)) * 1000;
  return Math.max(REFRESH_FALLBACK_MS, ttlMs);
}

function backoffDelay(name, retryAfterSec){
  backoff[name] = Math.min(backoff[name] + 1, 6);
  let delay = BACKOFF_BASE_MS * (2 ** (backoff[name] - 1));
  delay = Math.min(delay, BACKOFF_MAX_MS);
  if (retryAfterSec) delay = Math.max(delay, retryAfterSec * 1000);
  return Math.max(REFRESH_FALLBACK_MS, jitter(delay));
}

function resetBackoff(name){
  backoff[name] = 0;
}

function parseRetryAfter(header){
  if (!header) return 0;
  const v = header.trim();
  if (/^\d+$/.test(v)) return Number(v);
  const t = Date.parse(v);
  if (Number.isFinite(t)){
    return Math.max(0, Math.round((t - Date.now()) / 1000));
  }
  return 0;
}

function parseCacheTtlSeconds(headers){
  const cc = headers.get("Cache-Control") || "";
  const maxAgeMatch = cc.match(/max-age=(\d+)/i);
  if (maxAgeMatch){
    const maxAge = Number(maxAgeMatch[1]);
    const age = Number(headers.get("Age") || 0);
    const ttl = Math.max(0, maxAge - (Number.isFinite(age) ? age : 0));
    return Number.isFinite(ttl) ? ttl : 0;
  }
  const expires = headers.get("Expires");
  if (expires){
    const ts = Date.parse(expires);
    if (Number.isFinite(ts)){
      return Math.max(0, Math.round((ts - Date.now()) / 1000));
    }
  }
  return 0;
}

async function fetchJsonWithMeta(url){
  const c = new AbortController();
  const t = setTimeout(() => c.abort(), FETCH_TIMEOUT_MS);
  try{
    const r = await fetch(url, { signal:c.signal });
    const retryAfterSec = parseRetryAfter(r.headers.get("Retry-After"));
    const headerTtl = parseCacheTtlSeconds(r.headers);
    if(!r.ok){
      const err = new Error(`HTTP ${r.status}`);
      err.retryAfterSec = retryAfterSec;
      err.status = r.status;
      throw err;
    }
    const payload = await r.json();
    const payloadTtl = toSecs(payload?.cache_ttl_sec);
    return {
      payload,
      ttlSec: Math.max(headerTtl, payloadTtl),
      retryAfterSec
    };
  } finally {
    clearTimeout(t);
  }
}

function busEta(item){
  const secsRaw = toSecs(item.timeToStation);
  const secs = Math.max(0, secsRaw);

  if (secs < 60) return { text:"Odjazd", depart:true };

  const m = mins(secs);
  if (m <= 5)  return { text:`${m} min`, bussoon:true };
  if (m <= 15) return { text:`${m} min`, busgreen:true };

  return {
    text: new Date(item.expectedArrival)
      .toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit'})
  };
}

function tubeEta(item){
  const secs = Math.max(0, toSecs(item.timeToStation));
  if (secs < 60) return { text:"Odjazd", depart:true };

  const m = mins(secs);
  if (m <= 15) return { text:`${m} min`, soon15:true };

  return {
    text: new Date(item.expectedArrival)
      .toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit'})
  };
}

function hhmmToDate(runDate, hhmm){
  if(!runDate || !hhmm) return null;
  const d = new Date(runDate+"T00:00:00");
  d.setHours(Number(hhmm.slice(0,2)), Number(hhmm.slice(2,4)));
  const now = new Date();
  if (d.getTime() < now.getTime() - 6*3600*1000) d.setDate(d.getDate()+1);
  return d;
}

function railEta(svc){
  const dep = hhmmToDate(svc.runDate, svc.etd || svc.std);
  if (!dep) return { text:svc.etd || svc.std || "--" };

  const diffSec = Math.max(0, Math.floor((dep - new Date())/1000));
  if (diffSec < 60) return { text:"Odjazd", depart:true };

  const dm = mins(diffSec);
  if (dm <= 15) return { text:`${dm} min`, soon15:true };

  return {
    text: dep.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit'})
  };
}

function rowHtml({ line, dest, etaText, etaSoon15, etaBusSoon, etaBusGreen, etaDepart, subline }){
  const cls = [
    "eta",
    etaSoon15 ? "soon15" : "",
    etaBusSoon ? "bussoon" : "",
    etaBusGreen ? "busgreen" : "",
    etaDepart ? "depart" : ""
  ].join(" ").trim();

  return `
    <div class="row">
      <div class="topline">
        <div class="left">
          <div class="line">${esc(line)}</div>
          <div class="pipe">|</div>
          <div class="dest">${esc(dest)}</div>
        </div>
        <div class="${cls}">${esc(etaText)}</div>
      </div>
      ${subline ? `<div class="subline">${esc(subline)}</div>` : ""}
    </div>
  `;
}

async function loadRail(){
  try{
    const { payload, ttlSec } = await fetchJsonWithMeta(RTT_URL);
    const servicesRaw = Array.isArray(payload?.services) ? payload.services : [];
    const services = servicesRaw.filter(s => !s.cancelled);

    if(!services.length){
      railList.style.display="none";
      railFallback.style.display="block";
      setStatus("railStatus", false);
      schedule("rail", loadRail, nextDelayFromTtl(ttlSec));
      return;
    }

    railFallback.style.display="none";
    railList.style.display="block";
    setStatus("railStatus", true);

    const rows = services
      .sort((a,b)=>{
        const da = hhmmToDate(a.runDate, a.etd || a.std) || new Date(8640000000000000);
        const db = hhmmToDate(b.runDate, b.etd || b.std) || new Date(8640000000000000);
        return da - db;
      })
      .slice(0, MAX_ITEMS)
      .map(s=>{
        const eta = railEta(s);
        const viaLabel = s.via === "HHY"
          ? "via Highbury & Islington"
          : (s.via === "FPK" ? "via Finsbury Park" : "");
        return rowHtml({
          line: s.operator || "Train",
          dest: s.destination || "-",
          etaText: eta.text,
          etaSoon15: eta.soon15,
          etaBusSoon: false,
          etaBusGreen: false,
          etaDepart: eta.depart,
          subline: `${s.platform ? `Peron ${s.platform}` : "Peron -"}${viaLabel ? ` • ${viaLabel}` : ""}`
        });
      });

    renderRows("railList", rows);
    resetBackoff("rail");
    schedule("rail", loadRail, nextDelayFromTtl(ttlSec));
    setLastUpdate();
  }catch(err){
    railList.style.display="none";
    railFallback.style.display="block";
    setStatus("railStatus", false);
    schedule("rail", loadRail, backoffDelay("rail", err.retryAfterSec));
  }
}

async function loadBus(){
  try{
    const { payload, ttlSec } = await fetchJsonWithMeta(BUS_URL);
    const arr = Array.isArray(payload?.data) ? payload.data : [];

    const combined = arr
      .filter(x => {
        const ln = String(x.lineName).toUpperCase();
        return ln === BUS_PRIMARY || ln === BUS_FALLBACK;
      })
      .filter(x => (x.timeToStation ?? 0) >= 0)
      .sort(byTime)
      .slice(0, MAX_ITEMS);

    if(!combined.length){
      renderMessage("busList", `Brak danych live dla ${BUS_PRIMARY} i ${BUS_FALLBACK}.`);
      setStatus("busStatus", false);
      schedule("bus", loadBus, nextDelayFromTtl(ttlSec));
      return;
    }

    setStatus("busStatus", true);

    const rows = combined.map(x=>{
      const eta = busEta(x);
      return rowHtml({
        line: x.lineName,
        dest: x.destinationName || "",
        etaText: eta.text,
        etaSoon15: eta.soon15,
        etaBusSoon: eta.bussoon,
        etaBusGreen: eta.busgreen,
        etaDepart: eta.depart,
        subline: null
      });
    });

    renderRows("busList", rows);
    resetBackoff("bus");
    schedule("bus", loadBus, nextDelayFromTtl(ttlSec));
    setLastUpdate();
  }catch(err){
    renderMessage("busList", "Błąd danych bus.");
    setStatus("busStatus", false);
    schedule("bus", loadBus, backoffDelay("bus", err.retryAfterSec));
  }
}

async function loadTube(){
  try{
    const { payload, ttlSec } = await fetchJsonWithMeta(TUBE_URL);
    const arr = Array.isArray(payload?.data) ? payload.data : [];

    const westbound = arr
      .filter(x => /westbound/i.test(x.platformName || ""))
      .filter(x => (x.timeToStation ?? 0) >= 0)
      .sort(byTime)
      .slice(0, MAX_ITEMS);

    if(!westbound.length){
      renderMessage("tubeList", "Brak danych Westbound.");
      setStatus("tubeStatus", false);
      schedule("tube", loadTube, nextDelayFromTtl(ttlSec));
      return;
    }

    setStatus("tubeStatus", true);

    const rows = westbound.map(x=>{
      const eta = tubeEta(x);
      return rowHtml({
        line: "Piccadilly",
        dest: (x.destinationName || "").replace(/ Underground Station/i, ""),
        etaText: eta.text,
        etaSoon15: eta.soon15,
        etaBusSoon: false,
        etaBusGreen: false,
        etaDepart: eta.depart,
        subline: "Westbound"
      });
    });

    renderRows("tubeList", rows);
    resetBackoff("tube");
    schedule("tube", loadTube, nextDelayFromTtl(ttlSec));
    setLastUpdate();
  }catch(err){
    renderMessage("tubeList", "Błąd danych tube.");
    setStatus("tubeStatus", false);
    schedule("tube", loadTube, backoffDelay("tube", err.retryAfterSec));
  }
}

const PL_DAYS = [
  "Niedziela",
  "Poniedziałek",
  "Wtorek",
  "Środa",
  "Czwartek",
  "Piątek",
  "Sobota"
];

function updateClock(){
  const d = new Date();
  topDay.textContent = PL_DAYS[d.getDay()];
  topDate.textContent = d.toLocaleDateString('pl-PL',{day:'2-digit',month:'2-digit',year:'numeric'})
                         .replace(/\./g," / ").replace(/ /g,"");
  topTime.textContent = d.toLocaleTimeString('pl-PL',{hour:'2-digit',minute:'2-digit',second:'2-digit'});
}

function setLastUpdate(){
  lastUpdate.textContent =
    "Ostatnia aktualizacja: " +
    new Date().toLocaleTimeString('pl-PL',{hour:'2-digit',minute:'2-digit',second:'2-digit'});
}

setInterval(updateClock, 1000);
updateClock();

loadRail();
loadBus();
loadTube();
</script>
</body>
</html>
