<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TfL Panel</title>

<style>
body{
  margin:0; background:#000; color:#fff; font-family:sans-serif;
  min-height:100vh; overflow-y:auto; -webkit-overflow-scrolling:touch;
}

.header{
  position:sticky; top:0; z-index:10;
  padding:18px 60px; background:#000;
  border-bottom:2px solid #111;
  display:flex; justify-content:space-between; align-items:center;
}
#topDay{ font-size:52px; font-weight:600; letter-spacing:.5px; }
#topDate,#lastUpdate{ font-size:24px; color:#9a9a9a; }
#topTime{ font-size:72px; font-weight:600; letter-spacing:1px; line-height:1; text-align:right; }

.wrap{ padding:26px 60px 30px; display:grid; gap:24px; }
.card{ border:2px solid #222; border-radius:18px; padding:22px 26px; background:#050505; }
.title{ font-size:58px; font-weight:600; display:flex; justify-content:space-between; align-items:center; }
.subtitle{ font-size:26px; opacity:.7; margin:0 0 18px 0; }

.list{ display:flex; flex-direction:column; gap:10px; }
.row{ padding:8px 0; border-bottom:1px solid #111; }
.row:last-child{ border-bottom:none; }

.topline{ display:flex; justify-content:space-between; align-items:baseline; font-size:44px; line-height:1.25; }
.left{ display:flex; gap:14px; min-width:0; }
.line{ white-space:nowrap; font-weight:600; }
.pipe{ opacity:.6; }
.dest{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; font-weight:400; }

.eta{ font-weight:700; white-space:nowrap; }

.eta.red{ color:#ff4b4b; }
.eta.yellow{ color:#ffd54d; }
.eta.green{ color:#4cff4c; }
.eta.blue{ color:#45a9ff; }

.subline{ font-size:26px; color:#9a9a9a; line-height:1.25; padding-bottom:4px; }

.pill{
  font-size:26px; padding:3px 14px;
  border:1px solid #333; border-radius:999px;
  display:inline-block;
}
.pill.live{ animation:livePulse 3.8s ease-in-out infinite; }
@keyframes livePulse{
  0%,100%{ opacity:.75; transform:scale(1); }
  50%{ opacity:1; transform:scale(1.04); }
}

.attribution{
  font-size:18px;
  color:#7d7d7d;
  padding:0 60px 28px;
}

.muted{ opacity:.65; }
.bigmsg{ font-size:34px; opacity:.8; padding:8px 0; }
</style>
</head>

<body>
<div class="header">
  <div class="h-left">
    <div id="topDay">--</div>
    <div id="topDate">--</div>
  </div>
  <div class="h-right">
    <div id="topTime">--:--:--</div>
    <div id="lastUpdate">Last update: --:--:--</div>
  </div>
</div>

<div class="wrap">

  <section class="card">
    <div class="title">
      <span>Alexandra Palace</span>
      <span id="railStatus" class="pill muted">refreshing...</span>
    </div>
    <div class="subtitle">Next trains via Highbury &amp; Islington and/or Finsbury Park</div>
    <div id="railList" class="list muted">Loading data...</div>
    <div id="railFallback" class="bigmsg muted" style="display:none;">
      No RTT data (check proxy).
    </div>
  </section>

  <section class="card">
    <div class="title">
      <span>Nightingale Road</span>
      <span id="busStatus" class="pill muted">refreshing...</span>
    </div>
    <div class="subtitle">Next buses (221 + N91) via Bounds Green</div>
    <div id="busList" class="list muted">Loading data...</div>
  </section>

  <section class="card">
    <div class="title">
      <span>Bounds Green</span>
      <span id="tubeStatus" class="pill muted">refreshing...</span>
    </div>
    <div class="subtitle">Next Underground services via Finsbury Park (towards central)</div>
    <div id="tubeList" class="list muted">Loading data...</div>
  </section>

</div>

<div class="attribution">Powered by TfL Open Data</div>

<script>
const API_BASE = location.hostname
  ? `${location.protocol}//${location.hostname}:5010`
  : "http://127.0.0.1:5010";
const REFRESH_FALLBACK_MS = 60_000;
const FETCH_TIMEOUT_MS = 8000;
const MAX_ITEMS = 5;

const ETA_WALK_MIN = { train: 8, tube: 12, bus: 4 };
const ETA_BUFFER_MIN = { train: 4, tube: 4, bus: 2 };
const ETA_RED_SEC = 60;
const ETA_BLUE_MIN = 20;

const BUS_STOP_ID  = "490010277W";
const BUS_PRIMARY  = "221";
const BUS_FALLBACK = "N91";

const TUBE_LINE_ID = "piccadilly";
const TUBE_STOP_ID = "940GZZLUBDS";

const RTT_URL = `${API_BASE}/api/trains`;
const BUS_URL = `${API_BASE}/api/tfl/stop/${BUS_STOP_ID}/arrivals`;
const TUBE_URL = `${API_BASE}/api/tfl/line/${TUBE_LINE_ID}/arrivals/${TUBE_STOP_ID}`;

const BACKOFF_BASE_MS = 2000;
const BACKOFF_MAX_MS = 120_000;

const topDay = document.getElementById("topDay");
const topDate = document.getElementById("topDate");
const topTime = document.getElementById("topTime");
const lastUpdate = document.getElementById("lastUpdate");

const railList = document.getElementById("railList");
const railFallback = document.getElementById("railFallback");
const busList = document.getElementById("busList");
const tubeList = document.getElementById("tubeList");

const timers = { rail: null, bus: null, tube: null };
const backoff = { rail: 0, bus: 0, tube: 0 };

const esc = v => String(v ?? "").replace(/[&<>"']/g, m => ({
  "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
}[m]));

const mins = s => Math.max(0, Math.floor((s || 0) / 60));
const byTime = (a,b) => (a.timeToStation ?? 1e12) - (b.timeToStation ?? 1e12);

const toSecs = x => {
  const n = Number(x);
  return Number.isFinite(n) ? n : 0;
};

const toEtaSeconds = x => {
  const n = Number(x);
  return Number.isFinite(n) ? Math.max(0, n) : null;
};

const jitter = ms => Math.round(ms * (0.7 + Math.random() * 0.6));

function setStatus(id, ok){
  const el = document.getElementById(id);
  el.textContent = ok ? "live" : "no data";
  el.classList.toggle("muted", !ok);
  el.classList.toggle("live", ok);
}

function renderRows(id, rows){
  const el = document.getElementById(id);
  el.classList.remove("muted");
  el.innerHTML = rows.join("");
}

function renderMessage(id, msg){
  const el = document.getElementById(id);
  el.classList.add("muted");
  el.textContent = msg;
}

function schedule(name, fn, delayMs){
  clearTimeout(timers[name]);
  timers[name] = setTimeout(fn, delayMs);
}

function nextDelayFromTtl(ttlSec){
  // Respect upstream TTLs to avoid over-polling.
  const ttlMs = Math.max(0, toSecs(ttlSec)) * 1000;
  return Math.max(REFRESH_FALLBACK_MS, ttlMs);
}

function backoffDelay(name, retryAfterSec){
  backoff[name] = Math.min(backoff[name] + 1, 6);
  let delay = BACKOFF_BASE_MS * (2 ** (backoff[name] - 1));
  delay = Math.min(delay, BACKOFF_MAX_MS);
  if (retryAfterSec) delay = Math.max(delay, retryAfterSec * 1000);
  return Math.max(REFRESH_FALLBACK_MS, jitter(delay));
}

function resetBackoff(name){
  backoff[name] = 0;
}

function parseRetryAfter(header){
  if (!header) return 0;
  const v = header.trim();
  if (/^\d+$/.test(v)) return Number(v);
  const t = Date.parse(v);
  if (Number.isFinite(t)){
    return Math.max(0, Math.round((t - Date.now()) / 1000));
  }
  return 0;
}

function parseCacheTtlSeconds(headers){
  const cc = headers.get("Cache-Control") || "";
  const maxAgeMatch = cc.match(/max-age=(\d+)/i);
  if (maxAgeMatch){
    const maxAge = Number(maxAgeMatch[1]);
    const age = Number(headers.get("Age") || 0);
    const ttl = Math.max(0, maxAge - (Number.isFinite(age) ? age : 0));
    return Number.isFinite(ttl) ? ttl : 0;
  }
  const expires = headers.get("Expires");
  if (expires){
    const ts = Date.parse(expires);
    if (Number.isFinite(ts)){
      return Math.max(0, Math.round((ts - Date.now()) / 1000));
    }
  }
  return 0;
}

function toDate(value){
  if (!value) return null;
  const ts = Date.parse(value);
  return Number.isFinite(ts) ? new Date(ts) : null;
}

function formatClockTime(dt){
  if (!dt) return "--";
  return dt.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit'});
}

function formatEtaText(etaSec, clockTime){
  if (etaSec === null) return { text: clockTime || "--" };
  if (etaSec < ETA_RED_SEC) return { text: "Due" };
  if (etaSec <= ETA_BLUE_MIN * 60) return { text: `${mins(etaSec)} min` };
  return { text: clockTime || "--" };
}

function getEtaClass(etaSec, transportType){
  if (etaSec === null) return "blue";
  if (etaSec < ETA_RED_SEC) return "red";
  if (etaSec >= ETA_BLUE_MIN * 60) return "blue";
  const walkMin = ETA_WALK_MIN[transportType] ?? 0;
  const walkSec = walkMin * 60;
  const bufferMin = ETA_BUFFER_MIN[transportType] ?? 0;
  const bufferSec = bufferMin * 60;
  if (etaSec >= walkSec + bufferSec) return "green";
  return "yellow";
}

async function fetchJsonWithMeta(url){
  const c = new AbortController();
  const t = setTimeout(() => c.abort(), FETCH_TIMEOUT_MS);
  try{
    const r = await fetch(url, { signal:c.signal });
    const retryAfterSec = parseRetryAfter(r.headers.get("Retry-After"));
    const headerTtl = parseCacheTtlSeconds(r.headers);
    if(!r.ok){
      const err = new Error(`HTTP ${r.status}`);
      err.retryAfterSec = retryAfterSec;
      err.status = r.status;
      throw err;
    }
    const payload = await r.json();
    const payloadTtl = toSecs(payload?.cache_ttl_sec);
    return {
      payload,
      ttlSec: Math.max(headerTtl, payloadTtl),
      retryAfterSec
    };
  } finally {
    clearTimeout(t);
  }
}

function hhmmToDate(runDate, hhmm){
  if(!runDate || !hhmm) return null;
  const d = new Date(runDate+"T00:00:00");
  d.setHours(Number(hhmm.slice(0,2)), Number(hhmm.slice(2,4)));
  const now = new Date();
  if (d.getTime() < now.getTime() - 6*3600*1000) d.setDate(d.getDate()+1);
  return d;
}

function rowHtml({ line, dest, etaText, etaClass, subline }){
  const cls = ["eta", etaClass].filter(Boolean).join(" ");

  return `
    <div class="row">
      <div class="topline">
        <div class="left">
          <div class="line">${esc(line)}</div>
          <div class="pipe">|</div>
          <div class="dest">${esc(dest)}</div>
        </div>
        <div class="${cls}">${esc(etaText)}</div>
      </div>
      ${subline ? `<div class="subline">${esc(subline)}</div>` : ""}
    </div>
  `;
}

async function loadRail(){
  try{
    const { payload, ttlSec } = await fetchJsonWithMeta(RTT_URL);
    const servicesRaw = Array.isArray(payload?.services) ? payload.services : [];
    const services = servicesRaw.filter(s => !s.cancelled);

    if(!services.length){
      railList.style.display="none";
      railFallback.style.display="block";
      setStatus("railStatus", false);
      schedule("rail", loadRail, nextDelayFromTtl(ttlSec));
      return;
    }

    railFallback.style.display="none";
    railList.style.display="block";
    setStatus("railStatus", true);

    const rows = services
      .sort((a,b)=>{
        const da = hhmmToDate(a.runDate, a.etd || a.std) || new Date(8640000000000000);
        const db = hhmmToDate(b.runDate, b.etd || b.std) || new Date(8640000000000000);
        return da - db;
      })
      .slice(0, MAX_ITEMS)
      .map(s=>{
        const dep = hhmmToDate(s.runDate, s.etd || s.std);
        const etaSec = dep ? Math.max(0, Math.floor((dep - new Date()) / 1000)) : null;
        const clockTime = dep ? formatClockTime(dep) : (s.etd || s.std || "--");
        const eta = formatEtaText(etaSec, clockTime);
        const viaCodes = Array.isArray(s.via) ? s.via : (s.via ? [s.via] : []);
        const viaNames = viaCodes.map(code => (
          code === "HHY" ? "Highbury & Islington"
          : (code === "FPK" ? "Finsbury Park" : code)
        ));
        const viaLabel = viaNames.length ? `via ${viaNames.join(" and ")}` : "";
        return rowHtml({
          line: s.operator || "Train",
          dest: s.destination || "-",
          etaText: eta.text,
          etaClass: getEtaClass(etaSec, "train"),
          subline: `${s.platform ? `Platform ${s.platform}` : "Platform -"}${viaLabel ? ` (${viaLabel})` : ""}`
        });
      });

    renderRows("railList", rows);
    resetBackoff("rail");
    schedule("rail", loadRail, nextDelayFromTtl(ttlSec));
    setLastUpdate();
  }catch(err){
    railList.style.display="none";
    railFallback.style.display="block";
    setStatus("railStatus", false);
    schedule("rail", loadRail, backoffDelay("rail", err.retryAfterSec));
  }
}

async function loadBus(){
  try{
    const { payload, ttlSec } = await fetchJsonWithMeta(BUS_URL);
    const arr = Array.isArray(payload?.data) ? payload.data : [];

    const combined = arr
      .filter(x => {
        const ln = String(x.lineName).toUpperCase();
        return ln === BUS_PRIMARY || ln === BUS_FALLBACK;
      })
      .filter(x => Number.isFinite(Number(x.timeToStation)))
      .filter(x => Number(x.timeToStation) >= 0)
      .sort(byTime)
      .slice(0, MAX_ITEMS);

    if(!combined.length){
      renderMessage("busList", `No live data for ${BUS_PRIMARY} and ${BUS_FALLBACK}.`);
      setStatus("busStatus", false);
      schedule("bus", loadBus, nextDelayFromTtl(ttlSec));
      return;
    }

    setStatus("busStatus", true);

    const rows = combined.map(x=>{
      const etaSec = toEtaSeconds(x.timeToStation);
      const eta = formatEtaText(etaSec, formatClockTime(toDate(x.expectedArrival)));
      return rowHtml({
        line: x.lineName,
        dest: x.destinationName || "",
        etaText: eta.text,
        etaClass: getEtaClass(etaSec, "bus"),
        subline: null
      });
    });

    renderRows("busList", rows);
    resetBackoff("bus");
    schedule("bus", loadBus, nextDelayFromTtl(ttlSec));
    setLastUpdate();
  }catch(err){
    renderMessage("busList", "Bus data error.");
    setStatus("busStatus", false);
    schedule("bus", loadBus, backoffDelay("bus", err.retryAfterSec));
  }
}

async function loadTube(){
  try{
    const { payload, ttlSec } = await fetchJsonWithMeta(TUBE_URL);
    const arr = Array.isArray(payload?.data) ? payload.data : [];

    const westbound = arr
      .filter(x => /westbound/i.test(x.platformName || ""))
      .filter(x => Number.isFinite(Number(x.timeToStation)))
      .filter(x => Number(x.timeToStation) >= 0)
      .sort(byTime)
      .slice(0, MAX_ITEMS);

    if(!westbound.length){
      renderMessage("tubeList", "No westbound data.");
      setStatus("tubeStatus", false);
      schedule("tube", loadTube, nextDelayFromTtl(ttlSec));
      return;
    }

    setStatus("tubeStatus", true);

    const rows = westbound.map(x=>{
      const etaSec = toEtaSeconds(x.timeToStation);
      const eta = formatEtaText(etaSec, formatClockTime(toDate(x.expectedArrival)));
      return rowHtml({
        line: "Piccadilly",
        dest: (x.destinationName || "").replace(/ Underground Station/i, ""),
        etaText: eta.text,
        etaClass: getEtaClass(etaSec, "tube"),
        subline: "Westbound"
      });
    });

    renderRows("tubeList", rows);
    resetBackoff("tube");
    schedule("tube", loadTube, nextDelayFromTtl(ttlSec));
    setLastUpdate();
  }catch(err){
    renderMessage("tubeList", "Tube data error.");
    setStatus("tubeStatus", false);
    schedule("tube", loadTube, backoffDelay("tube", err.retryAfterSec));
  }
}

const EN_DAYS = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
];

function updateClock(){
  const d = new Date();
  topDay.textContent = EN_DAYS[d.getDay()];
  topDate.textContent = d.toLocaleDateString('en-GB',{day:'2-digit',month:'2-digit',year:'numeric'});
  topTime.textContent = d.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',second:'2-digit'});
}

function setLastUpdate(){
  lastUpdate.textContent =
    "Last update: " +
    new Date().toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',second:'2-digit'});
}

setInterval(updateClock, 1000);
updateClock();

loadRail();
loadBus();
loadTube();
</script>
</body>
</html>
