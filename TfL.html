<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TfL Panel</title>

<style>
body{
  margin:0; background:#000; color:#fff; font-family:sans-serif;
  min-height:100vh; overflow-y:auto; -webkit-overflow-scrolling:touch;
}

.header{
  position:sticky; top:0; z-index:10;
  padding:18px 60px; background:#000;
  border-bottom:2px solid #111;
  display:flex; justify-content:space-between; align-items:center;
}
#topDay{ font-size:58px; font-weight:600; letter-spacing:.5px; line-height:1; }
#topDate,#lastUpdate{ font-size:26px; color:#9a9a9a; }
#topTime{ font-size:58px; font-weight:600; letter-spacing:1px; line-height:1; text-align:right; }
.h-left{ display:flex; flex-direction:column; align-items:flex-start; gap:6px; }
.h-right{ display:flex; flex-direction:column; align-items:flex-end; gap:6px; }

.wrap{ padding:26px 60px 30px; display:grid; gap:24px; }
.card{ border:2px solid #222; border-radius:18px; padding:22px 26px; background:#050505; }
.title{ font-size:54px; font-weight:600; display:flex; justify-content:space-between; align-items:center; }
.title-right{ display:flex; gap:10px; align-items:center; }
.subtitle{ font-size:26px; opacity:.7; margin:0 0 18px 0; }

.list{ display:flex; flex-direction:column; gap:10px; }
.row{ padding:8px 0; border-bottom:1px solid #111; }
.row:last-child{ border-bottom:none; }

.topline{ display:flex; justify-content:space-between; align-items:baseline; font-size:40px; line-height:1.25; }
.left{ display:flex; gap:14px; min-width:0; }
.line{ white-space:nowrap; font-weight:600; }
.pipe{ opacity:.6; }
.dest{ white-space:nowrap; overflow:hidden; text-overflow:ellipsis; font-weight:400; }

.eta{ font-weight:700; white-space:nowrap; }

.eta-red{ color:#ff4b4b; }
.eta-yellow{ color:#ffd54d; }
.eta-green{ color:#4cff4c; }
.eta-blue{ color:#45a9ff; }
.delay-text{ color:#ff4b4b; }

.subline{ font-size:26px; color:#9a9a9a; line-height:1.25; padding-bottom:4px; }

.pill{
  font-size:26px; padding:3px 14px;
  border:1px solid #333; border-radius:999px;
  display:inline-block;
}
.pill.live{ animation:livePulse 3.8s ease-in-out infinite; }
.pill.delay{ color:#ff4b4b; border-color:#3a1212; }
.pill.hidden{ display:none; }
@keyframes livePulse{
  0%,100%{ opacity:.75; transform:scale(1); }
  50%{ opacity:1; transform:scale(1.04); }
}

.attribution{
  font-size:18px;
  color:#7d7d7d;
  padding:0 60px 28px;
}

.muted{ opacity:.65; }
.bigmsg{ font-size:30px; opacity:.8; padding:8px 0; }
</style>
</head>

<body>
<div class="header">
  <div class="h-left">
    <div id="topDay">--</div>
    <div id="topDate">--</div>
  </div>
  <div class="h-right">
    <div id="topTime">--:--:--</div>
    <div id="lastUpdate">Last update: --:--:--</div>
  </div>
</div>

<div class="wrap">

  <section class="card">
    <div class="title">
      <span>Alexandra Palace</span>
      <span id="railStatus" class="pill muted">refreshing...</span>
    </div>
    <div class="subtitle">Next trains via Highbury &amp; Islington and/or Finsbury Park</div>
    <div id="railList" class="list muted">Loading data...</div>
    <div id="railFallback" class="bigmsg muted" style="display:none;">
      No RTT data (check proxy).
    </div>
  </section>

  <section class="card">
    <div class="title">
      <span>Nightingale Road</span>
      <span id="busStatus" class="pill muted">refreshing...</span>
    </div>
    <div class="subtitle">Next buses (221 + N91) via Bounds Green</div>
    <div id="busList" class="list muted">Loading data...</div>
  </section>

  <section class="card">
    <div class="title">
      <span>Bounds Green</span>
      <div class="title-right">
        <span id="tubeLineStatus" class="pill muted hidden">status...</span>
        <span id="tubeStatus" class="pill muted">refreshing...</span>
      </div>
    </div>
    <div class="subtitle">Next Underground services via Finsbury Park (towards central)</div>
    <div id="tubeList" class="list muted">Loading data...</div>
  </section>

</div>

<div class="attribution">Powered by TfL Open Data</div>

<script>
const API_BASE = location.hostname
  ? `${location.protocol}//${location.hostname}:5010`
  : "http://127.0.0.1:5010";
const REFRESH_MIN_MS = 30_000;
const REFRESH_ALIGN_MS = 5_000;
const FETCH_TIMEOUT_MS = 8000;
const MAX_ITEMS = 5;

const ETA_WALK_MIN = { train: 9, tube: 13, bus: 5 };
const ETA_BUFFER_MIN = { train: 5, tube: 5, bus: 5 };
const ETA_RED_SEC = 60;

const BUS_STOP_ID  = "490010277W";
const BUS_PRIMARY  = "221";
const BUS_FALLBACK = "N91";

const TUBE_LINE_ID = "piccadilly";
const TUBE_STOP_ID = "940GZZLUBDS";

const RTT_URL = `${API_BASE}/api/trains`;
const BUS_URL = `${API_BASE}/api/tfl/stop/${BUS_STOP_ID}/arrivals`;
const TUBE_URL = `${API_BASE}/api/tfl/line/${TUBE_LINE_ID}/arrivals/${TUBE_STOP_ID}`;
const TUBE_STATUS_URL = `${API_BASE}/api/tfl/line/${TUBE_LINE_ID}/status`;

const BACKOFF_BASE_MS = 2000;
const BACKOFF_MAX_MS = 120_000;

const topDay = document.getElementById("topDay");
const topDate = document.getElementById("topDate");
const topTime = document.getElementById("topTime");
const lastUpdate = document.getElementById("lastUpdate");

const railList = document.getElementById("railList");
const railFallback = document.getElementById("railFallback");
const busList = document.getElementById("busList");
const tubeList = document.getElementById("tubeList");
const tubeLineStatus = document.getElementById("tubeLineStatus");

const timers = { rail: null, bus: null, tube: null, tubeLine: null };
const backoff = { rail: 0, bus: 0, tube: 0, tubeLine: 0 };

const esc = v => String(v ?? "").replace(/[&<>"']/g, m => ({
  "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
}[m]));

const mins = s => Math.max(0, Math.floor((s || 0) / 60));
const byTime = (a,b) => (a.timeToStation ?? 1e12) - (b.timeToStation ?? 1e12);

const toSecs = x => {
  const n = Number(x);
  return Number.isFinite(n) ? n : 0;
};

const toEtaSeconds = x => {
  const n = Number(x);
  return Number.isFinite(n) ? Math.max(0, n) : null;
};

const jitter = ms => Math.round(ms * (0.7 + Math.random() * 0.6));

function setStatus(id, ok){
  const el = document.getElementById(id);
  el.textContent = ok ? "live" : "no data";
  el.classList.toggle("muted", !ok);
  el.classList.toggle("live", ok);
}

function isDelayText(text){
  return /delay/i.test(String(text || ""));
}

function setLineStatus(status, lineName, reason){
  if (!tubeLineStatus) return;
  const statusText = status ? String(status) : "";
  const isUnknown = !statusText || /^unknown$/i.test(statusText);
  if (isUnknown){
    tubeLineStatus.classList.add("hidden");
    tubeLineStatus.removeAttribute("title");
    return;
  }
  const nameText = lineName ? String(lineName) : "Line";
  const label = `${nameText}: ${statusText}`;
  const delayed = isDelayText(label) || isDelayText(reason);
  tubeLineStatus.textContent = label;
  tubeLineStatus.classList.remove("hidden");
  tubeLineStatus.classList.remove("muted");
  tubeLineStatus.classList.toggle("delay", delayed);
  if (reason){
    tubeLineStatus.title = String(reason);
  } else {
    tubeLineStatus.removeAttribute("title");
  }
}

function renderRows(id, rows){
  const el = document.getElementById(id);
  el.classList.remove("muted");
  el.innerHTML = rows.join("");
}

function renderMessage(id, msg){
  const el = document.getElementById(id);
  el.classList.add("muted");
  el.textContent = msg;
}

function alignDelayToBoundary(delayMs){
  const now = Date.now();
  const target = now + Math.max(0, delayMs);
  const nextBoundary = Math.ceil(target / REFRESH_ALIGN_MS) * REFRESH_ALIGN_MS;
  return Math.max(0, nextBoundary - now);
}

function schedule(name, fn, delayMs){
  clearTimeout(timers[name]);
  timers[name] = setTimeout(fn, alignDelayToBoundary(delayMs));
}

function nextDelayFromTtl(ttlSec){
  // Respect upstream TTLs to avoid over-polling.
  const ttlMs = Math.max(0, toSecs(ttlSec)) * 1000;
  return Math.max(REFRESH_MIN_MS, ttlMs);
}

function backoffDelay(name, retryAfterSec){
  backoff[name] = Math.min(backoff[name] + 1, 6);
  let delay = BACKOFF_BASE_MS * (2 ** (backoff[name] - 1));
  delay = Math.min(delay, BACKOFF_MAX_MS);
  if (retryAfterSec) delay = Math.max(delay, retryAfterSec * 1000);
  return Math.max(REFRESH_MIN_MS, jitter(delay));
}

function resetBackoff(name){
  backoff[name] = 0;
}

function parseRetryAfter(header){
  if (!header) return 0;
  const v = header.trim();
  if (/^\d+$/.test(v)) return Number(v);
  const t = Date.parse(v);
  if (Number.isFinite(t)){
    return Math.max(0, Math.round((t - Date.now()) / 1000));
  }
  return 0;
}

function parseCacheTtlSeconds(headers){
  const cc = headers.get("Cache-Control") || "";
  const maxAgeMatch = cc.match(/max-age=(\d+)/i);
  if (maxAgeMatch){
    const maxAge = Number(maxAgeMatch[1]);
    const age = Number(headers.get("Age") || 0);
    const ttl = Math.max(0, maxAge - (Number.isFinite(age) ? age : 0));
    return Number.isFinite(ttl) ? ttl : 0;
  }
  const expires = headers.get("Expires");
  if (expires){
    const ts = Date.parse(expires);
    if (Number.isFinite(ts)){
      return Math.max(0, Math.round((ts - Date.now()) / 1000));
    }
  }
  return 0;
}

function formatHHMMFromNow(etaSec){
  const d = new Date(Date.now() + (etaSec * 1000));
  return d.toLocaleTimeString('en-GB', { hour:'2-digit', minute:'2-digit' });
}

function formatEtaText(etaSec){
  if (etaSec === null) return "--";
  if (etaSec <= ETA_RED_SEC) return "Due";

  // <= 20:59 -> minuty
  if (etaSec < 21 * 60) return `${mins(etaSec)} min`;

  // >= 21:00 -> HH:MM
  return formatHHMMFromNow(etaSec);
}

function getEtaClass(etaSec, transportType){
  if (etaSec === null) return "";
  if (etaSec <= ETA_RED_SEC) return "eta-red";

  // >= 21:00 -> HH:MM -> default (no color class)
  if (etaSec >= 21 * 60) return "";

  const walkMin = ETA_WALK_MIN[transportType] ?? 0;
  const bufferMin = ETA_BUFFER_MIN[transportType] ?? 0;

  const minsToDeparture = Math.floor(etaSec / 60);
  if (minsToDeparture < walkMin) return "eta-yellow";
  if (minsToDeparture <= walkMin + bufferMin) return "eta-green";
  return "eta-blue";
}

async function fetchJsonWithMeta(url){
  const c = new AbortController();
  const t = setTimeout(() => c.abort(), FETCH_TIMEOUT_MS);
  try{
    const r = await fetch(url, { signal:c.signal });
    const serverDate = r.headers.get("Date");
    const fetchedAt = Number.isFinite(Date.parse(serverDate)) ? Date.parse(serverDate) : Date.now();
    const retryAfterSec = parseRetryAfter(r.headers.get("Retry-After"));
    const headerTtl = parseCacheTtlSeconds(r.headers);
    if(!r.ok){
      const err = new Error(`HTTP ${r.status}`);
      err.retryAfterSec = retryAfterSec;
      err.status = r.status;
      throw err;
    }
    const payload = await r.json();
    const payloadTtl = toSecs(payload?.cache_ttl_sec);
    return {
      payload,
      ttlSec: Math.max(headerTtl, payloadTtl),
      retryAfterSec,
      fetchedAt
    };
  } finally {
    clearTimeout(t);
  }
}

function hhmmToDate(runDate, hhmm){
  if(!runDate || !hhmm) return null;
  const text = String(hhmm).trim();
  if (!/^\d{4}$/.test(text)) return null;
  const hours = Number(text.slice(0,2));
  const minutes = Number(text.slice(2,4));
  if (!Number.isFinite(hours) || !Number.isFinite(minutes) || hours > 23 || minutes > 59) {
    return null;
  }
  const d = new Date(runDate+"T00:00:00");
  d.setHours(hours, minutes, 0, 0);
  const now = new Date();
  if (d.getTime() < now.getTime() - 6*3600*1000) d.setDate(d.getDate()+1);
  return d;
}

function rowHtml({ line, dest, etaText, etaClass, sublineHtml }){
  const cls = ["eta", etaClass].filter(Boolean).join(" ");

  return `
    <div class="row">
      <div class="topline">
        <div class="left">
          <div class="line">${esc(line)}</div>
          <div class="pipe">|</div>
          <div class="dest">${esc(dest)}</div>
        </div>
        <div class="${cls}">${esc(etaText)}</div>
      </div>
      ${sublineHtml ? `<div class="subline">${sublineHtml}</div>` : ""}
    </div>
  `;
}

async function loadRail(){
  try{
    const { payload, ttlSec, fetchedAt } = await fetchJsonWithMeta(RTT_URL);
    const servicesRaw = Array.isArray(payload?.services) ? payload.services : [];
    const services = servicesRaw.filter(s => !s.cancelled);

    if(!services.length){
      railList.style.display="none";
      railFallback.style.display="block";
      setStatus("railStatus", false);
      schedule("rail", loadRail, nextDelayFromTtl(ttlSec));
      return;
    }

    railFallback.style.display="none";
    railList.style.display="block";
    setStatus("railStatus", true);

    const rows = services
      .sort((a,b)=>{
        const da = hhmmToDate(a.runDate, a.etd || a.std) || new Date(8640000000000000);
        const db = hhmmToDate(b.runDate, b.etd || b.std) || new Date(8640000000000000);
        return da - db;
      })
      .slice(0, MAX_ITEMS)
      .map(s=>{
        const etdTime = hhmmToDate(s.runDate, s.etd);
        const stdTime = hhmmToDate(s.runDate, s.std);
        const dep = etdTime ?? (s.delayed ? null : stdTime);
        const etaSec = dep ? Math.max(0, Math.floor((dep - new Date()) / 1000)) : null;
        let etaText = formatEtaText(etaSec);
        let etaClass = getEtaClass(etaSec, "train");
        if (s.delayed && !dep){
          etaText = "Delayed";
          etaClass = "eta-red";
        }
        const viaCodes = Array.isArray(s.via) ? s.via : (s.via ? [s.via] : []);
        const viaNames = viaCodes.map(code => (
          code === "HHY" ? "Highbury & Islington"
          : (code === "FPK" ? "Finsbury Park" : code)
        ));
        const viaLabel = viaNames.length ? `via ${viaNames.join(" and ")}` : "";
        const delayMin = Number.isFinite(Number(s.delay_min)) ? Number(s.delay_min) : null;
        const delayLabel = s.delayed ? (delayMin ? `Delayed ${delayMin} min` : "Delayed") : "";
        const platformLabel = s.platform ? `Platform ${s.platform}` : "Platform -";
        const viaSuffix = viaLabel ? ` (${viaLabel})` : "";
        const delaySuffix = delayLabel ? ` | <span class="delay-text">${esc(delayLabel)}</span>` : "";
        return rowHtml({
          line: s.operator || "Train",
          dest: s.destination || "-",
          etaText,
          etaClass,
          sublineHtml: `${esc(platformLabel)}${esc(viaSuffix)}${delaySuffix}`
        });
      });

    renderRows("railList", rows);
    resetBackoff("rail");
    schedule("rail", loadRail, nextDelayFromTtl(ttlSec));
    setLastUpdate(fetchedAt);
  }catch(err){
    railList.style.display="none";
    railFallback.style.display="block";
    setStatus("railStatus", false);
    schedule("rail", loadRail, backoffDelay("rail", err.retryAfterSec));
  }
}

async function loadBus(){
  try{
    const { payload, ttlSec, fetchedAt } = await fetchJsonWithMeta(BUS_URL);
    const arr = Array.isArray(payload?.data) ? payload.data : [];

    const combined = arr
      .filter(x => {
        const ln = String(x.lineName).toUpperCase();
        return ln === BUS_PRIMARY || ln === BUS_FALLBACK;
      })
      .filter(x => Number.isFinite(Number(x.timeToStation)))
      .filter(x => Number(x.timeToStation) >= 0)
      .sort(byTime)
      .slice(0, MAX_ITEMS);

    if(!combined.length){
      renderMessage("busList", `No live data for ${BUS_PRIMARY} and ${BUS_FALLBACK}.`);
      setStatus("busStatus", false);
      schedule("bus", loadBus, nextDelayFromTtl(ttlSec));
      return;
    }

    setStatus("busStatus", true);

    const rows = combined.map(x=>{
      const etaSec = toEtaSeconds(x.timeToStation);
      const etaText = formatEtaText(etaSec);
      return rowHtml({
        line: x.lineName,
        dest: x.destinationName || "",
        etaText,
        etaClass: getEtaClass(etaSec, "bus"),
        sublineHtml: null
      });
    });

    renderRows("busList", rows);
    resetBackoff("bus");
    schedule("bus", loadBus, nextDelayFromTtl(ttlSec));
    setLastUpdate(fetchedAt);
  }catch(err){
    renderMessage("busList", "Bus data error.");
    setStatus("busStatus", false);
    schedule("bus", loadBus, backoffDelay("bus", err.retryAfterSec));
  }
}

async function loadTube(){
  try{
    const { payload, ttlSec, fetchedAt } = await fetchJsonWithMeta(TUBE_URL);
    const arr = Array.isArray(payload?.data) ? payload.data : [];

    const westbound = arr
      .filter(x => /westbound/i.test(x.platformName || ""))
      .filter(x => Number.isFinite(Number(x.timeToStation)))
      .filter(x => Number(x.timeToStation) >= 0)
      .sort(byTime)
      .slice(0, MAX_ITEMS);

    if(!westbound.length){
      renderMessage("tubeList", "No westbound data.");
      setStatus("tubeStatus", false);
      schedule("tube", loadTube, nextDelayFromTtl(ttlSec));
      return;
    }

    setStatus("tubeStatus", true);

    const rows = westbound.map(x=>{
      const etaSec = toEtaSeconds(x.timeToStation);
      const etaText = formatEtaText(etaSec);
      return rowHtml({
        line: "Piccadilly",
        dest: (x.destinationName || "").replace(/ Underground Station/i, ""),
        etaText,
        etaClass: getEtaClass(etaSec, "tube"),
        sublineHtml: esc("Westbound")
      });
    });

    renderRows("tubeList", rows);
    resetBackoff("tube");
    schedule("tube", loadTube, nextDelayFromTtl(ttlSec));
    setLastUpdate(fetchedAt);
  }catch(err){
    renderMessage("tubeList", "Tube data error.");
    setStatus("tubeStatus", false);
    schedule("tube", loadTube, backoffDelay("tube", err.retryAfterSec));
  }
}

async function loadTubeStatus(){
  try{
    const { payload, ttlSec, fetchedAt } = await fetchJsonWithMeta(TUBE_STATUS_URL);
    const data = payload?.data || {};
    const status = typeof data.status === "string" ? data.status : "";
    const reason = typeof data.reason === "string" ? data.reason : "";
    const lineName = typeof data.line_name === "string" ? data.line_name : "Line";
    setLineStatus(status, lineName, reason);
    resetBackoff("tubeLine");
    schedule("tubeLine", loadTubeStatus, nextDelayFromTtl(ttlSec));
    setLastUpdate(fetchedAt);
  }catch(err){
    setLineStatus("", "", "");
    schedule("tubeLine", loadTubeStatus, backoffDelay("tubeLine", err.retryAfterSec));
  }
}

const EN_DAYS = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
];

function updateClock(){
  const d = new Date();
  topDay.textContent = EN_DAYS[d.getDay()].toUpperCase();
  topDate.textContent = d.toLocaleDateString('en-GB',{day:'2-digit',month:'2-digit',year:'numeric'});
  topTime.textContent = d.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',second:'2-digit'});
}

function setLastUpdate(ts){
  const t = Number.isFinite(ts) ? new Date(ts) : new Date();
  lastUpdate.textContent =
    "Updated: " +
    t.toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',second:'2-digit'});
}

function scheduleClockTick(){
  updateClock();
  const now = Date.now();
  const delay = 1000 - (now % 1000);
  setTimeout(scheduleClockTick, delay);
}

scheduleClockTick();

loadRail();
loadBus();
loadTube();
loadTubeStatus();
</script>
</body>
</html>
